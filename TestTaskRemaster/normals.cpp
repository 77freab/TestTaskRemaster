#include <main.h>

// Возвращает вектор между 2мя точками.
osg::Vec3 Vector(osg::Vec3 vPoint1, osg::Vec3 vPoint2)
{
  osg::Vec3 vVector;

  // Чтобы получить вектор между 2 точками (направление), нужно вычесть вторую
  // точку из первой.

  vVector[0] = vPoint1[0] - vPoint2[0];
  vVector[1] = vPoint1[1] - vPoint2[1];
  vVector[2] = vPoint1[2] - vPoint2[2];

  // Теперь возвращаем полученный результат

  return vVector;
}

// Возвращает вектор, перпендикулярный 2м переданным.
osg::Vec3 Cross(osg::Vec3 vVector1, osg::Vec3 vVector2)
{
  osg::Vec3 vNormal;                       // результирующий вектор

                                          // Еще раз, если у нас есть 2 вектора (2 стороны полигона), у нас есть плоскость.
                                          // cross находит вектор, перпендикулярный плоскости, составляемой 2мя векторами.
                                          // Формула в принципе проста, но сложна для запоминания:

                                          // Значение X для векторы вычисляется так:  (V1[1] * V2[2]) - (V1[2] * V2[1])
  vNormal[0] = ((vVector1[1] * vVector2[2]) - (vVector1[2] * vVector2[1]));

  // Значение Y для векторы вычисляется так:  (V1[2] * V2[0]) - (V1[0] * V2[2])
  vNormal[1] = ((vVector1[2] * vVector2[0]) - (vVector1[0] * vVector2[2]));

  // Значение Z для векторы вычисляется так:  (V1[0] * V2[1]) - (V1[1] * V2[0])
  vNormal[2] = ((vVector1[0] * vVector2[1]) - (vVector1[1] * vVector2[0]));

  return vNormal;  // Возвращаем результат (направление, куда направлен полигон - нормаль)
}

// Возвращает нормаль полигона
osg::Vec3 Normal(osg::Vec3 t1, osg::Vec3 t2, osg::Vec3 t3)
{
  osg::Vec3 vVector1 = Vector(t3, t1);
  osg::Vec3 vVector2 = Vector(t2, t1);

  // В функцию передаются три вектора - треугольник. Мы получаем vVector1 и vVector2 - его
  // стороны. Теперь, имея 2 стороны треугольника, мы можем получить из них cross().
  // (*ЗАМЕЧАНИЕ*) Важно: первым вектором мы передаём низ треугольника, а вторым - левую
  // сторону. Если мы поменяем их местами, нормаль будет повернута в противоположную
  // сторону. В нашем случае мы приняли решение всегда работать против часовой.

  osg::Vec3 vNormal = Cross(vVector1, vVector2);

  // Теперь, имея направление нормали, осталось сделать последнюю вещь. Сейчас её
  // длинна неизвестна, она может быть очень длинной. Мы сделаем её равной 1, это
  // называется нормализация. Чтобы сделать это, мы делим нормаль на её длинну.
  // Ну а как найти длинну? Мы используем эту формулу: magnitude = sqrt(x^2 + y^2 + z^2)
  
  vNormal.normalize();

  // Теперь вернём "нормализованную нормаль" =)
  // (*ПРИМЕЧАНИЕ*) если вы хотите увидеть, как работает нормализация, закомментируйте
  // предидущую линию. Вы увидите, как длинна нормаль до нормалицации. Я стого рекомендую
  // всегда использовать эту функцию. И запомните, неважно, какова длинна нормали
  // (конечно, кроме (0,0,0)), если мы её нормализуем, она всегда будет равна 1.

  return vNormal;
}